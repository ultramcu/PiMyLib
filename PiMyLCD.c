/*
NOTE

HARDWARE : Raspberry PI
IO_LIB : BCM2835 (http://www.open.com.au/mikem/bcm2835/)
AUTHER : MaIII Themd
EMAIL : maiii.themd@gmail.com
COMPILER : gcc version 4.6.3 (Debian 4.6.3-12+rpi1)
SINCE : 19/02/2013

Copyright MaIII Themd 
WEB : http://www.pishared.com/
FB : https://www.facebook.com/pages/Pi-Shared/350972691684305

PiMyLib
    + PiMyLCD Version 1.0 Release Date 24/02/2013
        - Support LCD5110 Graphic mode, Text Move 
        - LCD16x2 on 4 & 8 Bit Data Mode

*/

#include "PiMyLCD.h"



uint8_t const TABLE[480]=
{
    0x00,0x00,0x00,0x00,0x00, // 20 space
    0x00,0x00,0x5f,0x00,0x00, // 21 !
    0x00,0x07,0x00,0x07,0x00, // 22 "
    0x14,0x7f,0x14,0x7f,0x14, // 23 #
    0x24,0x2a,0x7f,0x2a,0x12, // 24 $
    0x23,0x13,0x08,0x64,0x62, // 25 %
    0x36,0x49,0x55,0x22,0x50, // 26 &
    0x00,0x05,0x03,0x00,0x00, // 27 '
    0x00,0x1c,0x22,0x41,0x00, // 28 (
    0x00,0x41,0x22,0x1c,0x00, // 29 )
    0x14,0x08,0x3e,0x08,0x14, // 2a *
    0x08,0x08,0x3e,0x08,0x08, // 2b +
    0x00,0x50,0x30,0x00,0x00, // 2c ,
    0x08,0x08,0x08,0x08,0x08, // 2d -
    0x00,0x60,0x60,0x00,0x00, // 2e .
    0x20,0x10,0x08,0x04,0x02, // 2f /
    0x3e,0x51,0x49,0x45,0x3e, // 30 0
    0x00,0x42,0x7f,0x40,0x00, // 31 1
    0x42,0x61,0x51,0x49,0x46, // 32 2
    0x21,0x41,0x45,0x4b,0x31, // 33 3
    0x18,0x14,0x12,0x7f,0x10, // 34 4
    0x27,0x45,0x45,0x45,0x39, // 35 5
    0x3c,0x4a,0x49,0x49,0x30, // 36 6
    0x01,0x71,0x09,0x05,0x03, // 37 7
    0x36,0x49,0x49,0x49,0x36, // 38 8
    0x06,0x49,0x49,0x29,0x1e, // 39 9
    0x00,0x36,0x36,0x00,0x00, // 3a :
    0x00,0x56,0x36,0x00,0x00, // 3b ;
    0x08,0x14,0x22,0x41,0x00, // 3c <
    0x14,0x14,0x14,0x14,0x14, // 3d =
    0x00,0x41,0x22,0x14,0x08, // 3e >
    0x02,0x01,0x51,0x09,0x06, // 3f ?
    0x32,0x49,0x79,0x41,0x3e, // 40 @
    0x7e,0x11,0x11,0x11,0x7e, // 41 A
    0x7f,0x49,0x49,0x49,0x36, // 42 B
    0x3e,0x41,0x41,0x41,0x22, // 43 C
    0x7f,0x41,0x41,0x22,0x1c, // 44 D
    0x7f,0x49,0x49,0x49,0x41, // 45 E
    0x7f,0x09,0x09,0x09,0x01, // 46 F
    0x3e,0x41,0x49,0x49,0x7a, // 47 G
    0x7f,0x08,0x08,0x08,0x7f, // 48 H
    0x00,0x41,0x7f,0x41,0x00, // 49 I
    0x20,0x40,0x41,0x3f,0x01, // 4a J
    0x7f,0x08,0x14,0x22,0x41, // 4b K
    0x7f,0x40,0x40,0x40,0x40, // 4c L
    0x7f,0x02,0x0c,0x02,0x7f, // 4d M
    0x7f,0x04,0x08,0x10,0x7f, // 4e N
    0x3e,0x41,0x41,0x41,0x3e,  // 4f O
    0x7f,0x09,0x09,0x09,0x06, // 50 P
    0x3e,0x41,0x51,0x21,0x5e, // 51 Q
    0x7f,0x09,0x19,0x29,0x46, // 52 R
    0x46,0x49,0x49,0x49,0x31, // 53 S
    0x01,0x01,0x7f,0x01,0x01, // 54 T
    0x3f,0x40,0x40,0x40,0x3f, // 55 U
    0x1f,0x20,0x40,0x20,0x1f, // 56 V
    0x3f,0x40,0x38,0x40,0x3f, // 57 W
    0x63,0x14,0x08,0x14,0x63, // 58 X
    0x07,0x08,0x70,0x08,0x07, // 59 Y
    0x61,0x51,0x49,0x45,0x43, // 5a Z
    0x00,0x7f,0x41,0x41,0x00, // 5b [
    0x02,0x04,0x08,0x10,0x20, // 5c
    0x00,0x41,0x41,0x7f,0x00, // 5d
    0x04,0x02,0x01,0x02,0x04, // 5e
    0x40,0x40,0x40,0x40,0x40, // 5f
    0x00,0x01,0x02,0x04,0x00, // 60
    0x20,0x54,0x54,0x54,0x78, // 61 a
    0x7f,0x48,0x44,0x44,0x38, // 62 b
    0x38,0x44,0x44,0x44,0x20, // 63 c
    0x38,0x44,0x44,0x48,0x7f, // 64 d
    0x38,0x54,0x54,0x54,0x18, // 65 e
    0x08,0x7e,0x09,0x01,0x02, // 66 f
    0x0c,0x52,0x52,0x52,0x3e, // 67 g
    0x7f,0x08,0x04,0x04,0x78, // 68 h
    0x00,0x44,0x7d,0x40,0x00, // 69 i
    0x20,0x40,0x44,0x3d,0x00, // 6a j
    0x7f,0x10,0x28,0x44,0x00, // 6b k
    0x00,0x41,0x7f,0x40,0x00, // 6c l
    0x7c,0x04,0x18,0x04,0x78, // 6d m
    0x7c,0x08,0x04,0x04,0x78, // 6e n
    0x38,0x44,0x44,0x44,0x38, // 6f o
    0x7c,0x14,0x14,0x14,0x08, // 70 p
    0x08,0x14,0x14,0x18,0x7c, // 71 q
    0x7c,0x08,0x04,0x04,0x08, // 72 r
    0x48,0x54,0x54,0x54,0x20, // 73 s
    0x04,0x3f,0x44,0x40,0x20, // 74 t
    0x3c,0x40,0x40,0x20,0x7c, // 75 u
    0x1c,0x20,0x40,0x20,0x1c, // 76 v
    0x3c,0x40,0x30,0x40,0x3c, // 77 w
    0x44,0x28,0x10,0x28,0x44, // 78 x
    0x0c,0x50,0x50,0x50,0x3c, // 79 y
    0x44,0x64,0x54,0x4c,0x44, // 7a z
    0x00,0x08,0x36,0x41,0x00, // 7b
    0x00,0x00,0x7f,0x00,0x00, // 7c
    0x00,0x41,0x36,0x08,0x00, // 7d
    0x10,0x08,0x08,0x10,0x08, // 7e
    0x78,0x46,0x41,0x46,0x78  // 7f
};


const unsigned char pishared_img[504] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x8C, 0x04, 0x04, 0x06, 0x06, 0x06, 0x06, 0x86, 0x06, 0x04, 0x04, 0x0C, 0x18, 0x70, 0xC0, 0xF0, 0x18, 0x0C, 0x0C, 0x04, 0x06, 0x86, 0x06, 0x06, 0x06, 0x06, 0x04, 0x04, 0x8C, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xC0, 0x00, 0xE0, 0xC0, 0x00, 0xE0, 0x60, 0xE0, 0x00, 0xE0, 0xE0, 0x00, 0xC0, 0x60, 0xE0, 0x00, 0xC0, 0xE0, 0x00, 0xC0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0E, 0x98, 0xF0, 0x70, 0x60, 0x60, 0x60, 0x60, 0xE1, 0x72, 0x7E, 0x3C, 0x3F, 0x3F, 0x3F, 0x3E, 0x7C, 0xF2, 0xE1, 0x61, 0x60, 0x60, 0x60, 0xE0, 0xF0, 0x98, 0x0E, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x87, 0x81, 0x83, 0x07, 0xA1, 0x00, 0x03, 0x07, 0x01, 0x01, 0x07, 0x03, 0x00, 0x01, 0x07, 0x03, 0x01, 0x07, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x78, 0x7F, 0xE3, 0xF0, 0x78, 0x18, 0x1C, 0x0E, 0x0F, 0x0F, 0x0C, 0x0C, 0x18, 0xF8, 0xF8, 0xF8, 0x18, 0x0C, 0x04, 0x07, 0x07, 0x0E, 0x0C, 0x18, 0x70, 0xE1, 0xE7, 0x3F, 0x78, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x10, 0x10, 0x1F, 0x06, 0x9F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF3, 0x80, 0x80, 0xE0, 0xFF, 0xFF, 0xF0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0x60, 0x30, 0x38, 0x1F, 0x1F, 0x1F, 0x18, 0x30, 0x60, 0xE0, 0xC0, 0xC0, 0xE0, 0xE0, 0x70, 0x7F, 0x7C, 0xC0, 0x80, 0xC0, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x6E, 0x4A, 0x56, 0x34, 0x00, 0x7F, 0x02, 0x02, 0x7E, 0x00, 0x74, 0x5A, 0x4A, 0x7E, 0x40, 0x3C, 0x3E, 0x02, 0x18, 0x7E, 0x4A, 0x4A, 0x2C, 0x00, 0x3C, 0x66, 0x42, 0x7F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x70, 0xC0, 0x80, 0x80, 0x01, 0x03, 0x07, 0xBF, 0xFF, 0xF0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0xF8, 0x9F, 0x03, 0x01, 0x00, 0x80, 0x80, 0xC0, 0x70, 0x3F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0xF0, 0x98, 0x08, 0x98, 0x90, 0x60, 0xF8, 0x08, 0x08, 0xF0, 0x00, 0xF8, 0x18, 0x08, 0xF8, 0x18, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x07, 0x07, 0x0F, 0x19, 0x10, 0x30, 0x20, 0x20, 0x20, 0x30, 0x30, 0x19, 0x0F, 0x07, 0x07, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };



int init_gpio(st_lcd *lcd)
{

    int i = 0;
    if (!bcm2835_init())
    {
        return 1;
    }
    

    if(lcd->lcd_type == (int)_LCD_TYPE_PCD8544_)
    {

        bcm2835_gpio_fsel(lcd->lcd_pcd_8544.sec, BCM2835_GPIO_FSEL_OUTP);
        bcm2835_gpio_fsel(lcd->lcd_pcd_8544.rst, BCM2835_GPIO_FSEL_OUTP);
        bcm2835_gpio_fsel(lcd->lcd_pcd_8544.dc,  BCM2835_GPIO_FSEL_OUTP);
        bcm2835_gpio_fsel(lcd->lcd_pcd_8544.sdin, BCM2835_GPIO_FSEL_OUTP);
        bcm2835_gpio_fsel(lcd->lcd_pcd_8544.sclk, BCM2835_GPIO_FSEL_OUTP);
    }
    else if(lcd->lcd_type == (int)_LCD_TYPE_16x2_)
    {
    	int start = 0;
        bcm2835_gpio_fsel(lcd->lcd_16x2.rs, BCM2835_GPIO_FSEL_OUTP);
        //bcm2835_gpio_fsel(lcd->lcd_16x2.rw, BCM2835_GPIO_FSEL_OUTP);
        bcm2835_gpio_fsel(lcd->lcd_16x2.en, BCM2835_GPIO_FSEL_OUTP);

        if(lcd->lcd_16x2.data_mode == _LCD_TYPE_16x2_MODE_4_BIT)
        {
        	start = 4;
        }


        for(i = start; i < 8; i++)
        {
        	bcm2835_gpio_fsel(lcd->lcd_16x2.data[i], BCM2835_GPIO_FSEL_OUTP);
        }
        
    }
    else
    {
        
    }
    
    
	return 0;
}

void gpio_on(RPiGPIOPin pin)
{
	bcm2835_gpio_write(pin, HIGH);
}

void gpio_off(RPiGPIOPin pin)
{
	bcm2835_gpio_write(pin, LOW);
}




int printl(st_lcd *lcd,uint8_t auto_cut,uint8_t pos_x,uint8_t pos_y, char *fmt, ... )
{
	va_list args;   
	uint8_t len = 0;
	uint8_t i = 0;
	uint8_t line = 1;
	uint8_t max_char = 0;
	uint8_t cnt_new_line = 0;
	uint8_t x = 0;
	uint8_t y = 0;
	uint8_t lcd_bias = 1;
	uint8_t all_char = 0;
	uint8_t all_line = 0;


	if (strlen(fmt) < sizeof(lcd->pmsg))
	{
		va_start( args, fmt ); 
		vsprintf( lcd->pmsg, fmt, args );
		va_end( args );	
	}
	else
	{
		printf("!ERROR: print_db string more than 200 char\r\n");
		return;
	}

	len = strlen(lcd->pmsg);



	

	
	x = pos_x;
	y = pos_y;
	cnt_new_line = pos_x;
	if(lcd->lcd_type == (int)_LCD_TYPE_PCD8544_)
	{
		all_char = 84;
		all_line = 14;
		lcd_bias = 6;
	}
	else if(lcd->lcd_type == (int)_LCD_TYPE_16x2_)
	{
		all_char = 32;
		all_line = 16;
		lcd_bias = 1;
	}


	if(auto_cut == 1)
	{
		max_char = (all_char - pos_x - (pos_y * all_line));
	}
	else
	{
		max_char = (all_line - pos_x);
	}

	lcd_goto_xy(lcd, x * lcd_bias, y);



	for(i = 0; i < len && i < max_char; i++)
	{

		if(auto_cut == 1)
		{

			if((cnt_new_line%all_line == 0 && cnt_new_line != 0) || lcd->pmsg[i] == '\n')
			{
				y++;
				x = 0;
				lcd_goto_xy(lcd, x * lcd_bias, y);

				if(lcd->pmsg[i] == '\n')
				{
					cnt_new_line = 0;
					continue;
				}
			}
			cnt_new_line++;
		}



		if(lcd->pmsg[i] != '\0')
		{
			if(lcd->lcd_type == (int)_LCD_TYPE_PCD8544_)
			{
				
				lcd_print_char(lcd,lcd->pmsg[i]); 
	
			}
			else if(lcd->lcd_type == (int)_LCD_TYPE_16x2_)
			{
				lcd_write_data_or_cmd(lcd,1, lcd->pmsg[i]);
			}

		}

	}




	return 0;
}


void draw_image_84x48(st_lcd *lcd,unsigned char display_mode,unsigned char *image)
{

	int i = 0;
	int j = 0;
	int cnt = 0;

	if(lcd->lcd_type != (int)_LCD_TYPE_PCD8544_)
	{
		return;
	}

	for(i = 0; i < 6; i++)
	{
		for(j = 0; j < 84; j++)
		{
			lcd_write_data_or_cmd(lcd,0,0x40 | (i & 0x07 ) );
			lcd_write_data_or_cmd(lcd,0,0x80 | (j & 0x7f ) );

			if(display_mode != 1)
			{
				lcd_write_data_or_cmd(lcd,1,image[cnt++]);
			}
			else
			{
				lcd_write_data_or_cmd(lcd,1,~image[cnt++]);
			}
		
		}	
	}
}



void lcd_test(st_lcd *lcd)
{
	uint8_t i;
	printf("mai\r\n");
    if(lcd->lcd_type == (int)_LCD_TYPE_PCD8544_)
    {
    	lcd_clear(lcd);
    	printl(lcd,1,0,0,"   Hello !!\n\n Raspberry PI\n\n Peak Robotics  \\o[0-0]>/");
    }
    else if(lcd->lcd_type == (int)_LCD_TYPE_16x2_)
    {
		
    	printl(lcd,1,0,0,"ABCDEFGHIJKLMNOPQRSTUVWXYZ*&^+$#");
    }
    
}


void glcd_test(st_lcd *lcd)
{
	int i = 0;
	int j = 0;
	int cnt = 0;

	for(i = 0; i < 6; i++)
	{
		for(j = 0; j < 84; j++)
		{
			lcd_write_data_or_cmd(lcd,0,0x40 | (i & 0x07 ) );
			lcd_write_data_or_cmd(lcd,0,0x80 | (j & 0x7f ) );

			lcd_write_data_or_cmd(lcd,1,pishared_img[cnt++]);
		}	
	}
}


void delay_us(unsigned long int cnt)
{
	usleep(cnt);
}

void delay_ms(unsigned long int cnt)
{
	bcm2835_delayMicroseconds(cnt);
}


void lcd_init(st_lcd *lcd)
{

	switch(lcd->lcd_type)
	{
		case (int)_LCD_TYPE_PCD8544_:
			{
				gpio_on(lcd->lcd_pcd_8544.dc);
				gpio_on(lcd->lcd_pcd_8544.sec);
				delay_ms(20);
				
				gpio_off(lcd->lcd_pcd_8544.rst);
				delay_ms(500);
				gpio_on(lcd->lcd_pcd_8544.rst);
				lcd_write_data_or_cmd(lcd,0,0x21);
				lcd_write_data_or_cmd(lcd,0,0x00);
				lcd_write_data_or_cmd(lcd,0,0x13);
				lcd_write_data_or_cmd(lcd,0,0x20); 
				
				lcd_write_data_or_cmd(lcd,0,0x09);
				delay_ms(50);
				lcd_clear(lcd);
				delay_ms(10);
				lcd_write_data_or_cmd(lcd,0,0x08);
				delay_ms(10);
				lcd_write_data_or_cmd(lcd,0,0x0c);
			}
			break;

		case (int)_LCD_TYPE_16x2_:
			{


				if(lcd->lcd_16x2.data_mode == _LCD_TYPE_16x2_MODE_4_BIT)
				{
					
					lcd_write_data_or_cmd(lcd,0,0x2);
					delay_ms(500);
					lcd_write_data_or_cmd(lcd,0,0x28);
					delay_ms(500);
					lcd_write_data_or_cmd(lcd,0,0x0C);
					delay_ms(500);
				}
				else
				{
					lcd_write_data_or_cmd(lcd,0,0x38);
					delay_ms(500);
					lcd_write_data_or_cmd(lcd,0,0x0C);
					delay_ms(500);
				}	

				lcd_write_data_or_cmd(lcd,0,0x01);
				delay_ms(500);
				lcd_write_data_or_cmd(lcd,0,0x06);
				delay_ms(500);
			}
			break;
	}
}


void lcd_clear(st_lcd *lcd)
{
	uint8_t i;

	switch(lcd->lcd_type)
	{
		case (int)_LCD_TYPE_PCD8544_:
			{
				for(i=0;i<6;i++)
				{
					printl(lcd,0,0,i,"              ");
				}
			}
			break;

		case (int)_LCD_TYPE_16x2_:
			{
				lcd_write_data_or_cmd(lcd,0,0x01);
			}
			break;
		default:
			{
				
			}
			break;
	}

}




void lcd_write_data_or_cmd(st_lcd *lcd,uint8_t is_data, uint8_t data_or_cmd)
{

	switch(lcd->lcd_type)
	{
		case (int)_LCD_TYPE_PCD8544_:
			{
				(is_data == 1) ? gpio_on(lcd->lcd_pcd_8544.dc) : gpio_off(lcd->lcd_pcd_8544.dc);
				gpio_off(lcd->lcd_pcd_8544.sec);
				i2c_write_to_5110(lcd,data_or_cmd);
				gpio_on(lcd->lcd_pcd_8544.sec);	
			}
			break;

		case (int)_LCD_TYPE_16x2_:
			{

				uint8_t i = 0;
 				uint8_t cmd_bit[8];


			 	for(i = 0; i < 8; i++)
			 	{
			 		cmd_bit[i] = ((data_or_cmd>>i) & 0x01);
			 	}

				(is_data == 1) ? gpio_on(lcd->lcd_16x2.rs) : gpio_off(lcd->lcd_16x2.rs);
				
				if(lcd->lcd_16x2.data_mode == _LCD_TYPE_16x2_MODE_4_BIT)
				{
					
					delay_ms(50);
					gpio_on(lcd->lcd_16x2.en);
					delay_ms(50);

					for(i = 4; i < 8; i++)
				 	{
						cmd_bit[i] ? gpio_on(lcd->lcd_16x2.data[i]) : gpio_off(lcd->lcd_16x2.data[i]);
				 	}

					delay_ms(50);
					gpio_off(lcd->lcd_16x2.en);
					gpio_on(lcd->lcd_16x2.en);
					delay_ms(50);

					for(i = 0; i < 4; i++)
				 	{
						cmd_bit[i] ? gpio_on(lcd->lcd_16x2.data[i + 4]) : gpio_off(lcd->lcd_16x2.data[i + 4]);
				 	}

					delay_ms(50);
					gpio_off(lcd->lcd_16x2.en);
					delay_ms(50);


				}
				else
				{

					for(i = 0; i < 8; i++)
				 	{
						cmd_bit[i] ? gpio_on(lcd->lcd_16x2.data[i]) : gpio_off(lcd->lcd_16x2.data[i]);
				 	}

				 	gpio_on(lcd->lcd_16x2.en);
				 	delay_ms(100);
				 	gpio_off(lcd->lcd_16x2.en);

				 }


			}
			break;
		default:
			{
				
			}
			break;
	}


}


void i2c_write_to_5110(st_lcd *lcd,char data)
{
	char i;

	for (i = 8;i > 0;i--)
	{
		
		gpio_off(lcd->lcd_pcd_8544.sclk);
		delay_ms(1);

		if ( (data & 0x80) == 0)
		{
			gpio_off(lcd->lcd_pcd_8544.sdin);
		}
		else
		{
			gpio_on(lcd->lcd_pcd_8544.sdin);
		}
		delay_ms(1);
		gpio_on(lcd->lcd_pcd_8544.sclk);
		delay_ms(1);
		data=data<<1;
	}
}

void lcd_goto_xy(st_lcd *lcd,uint8_t x, uint8_t y)
{

	switch(lcd->lcd_type)
	{
		case (int)_LCD_TYPE_PCD8544_:
			{
				lcd_write_data_or_cmd(lcd,0,0x80 | (x & 0x7f ) );
				lcd_write_data_or_cmd(lcd,0,0x40 | (y & 0x07 ) );
			}
			break;

		case (int)_LCD_TYPE_16x2_:
			{
				if(y == 0)
				{

					lcd_write_data_or_cmd(lcd,0, 0x80 + x);
					usleep(100000);
				}
				else if(y == 1)
				{
					lcd_write_data_or_cmd(lcd,0, 0xc0 + x);
					usleep(100000);
				}

			}
			break;
		default:
			{
			}
			break;
	}

}

void lcd_print_char(st_lcd *lcd,uint8_t cvar)
{
	uint8_t char_row;

	switch(lcd->lcd_type)
	{
		case (int)_LCD_TYPE_PCD8544_:
			{
				if (cvar < 0x20)
					return;
				if (cvar > 0x7f)
					return;
			    
			    
			    lcd->char_pos = ((cvar - 0x20)*5);
			    
				for (char_row = 0;char_row < 5; char_row++)
				{
					if(lcd->char_pos+char_row >= 0 && lcd->char_pos+char_row < 480)
					{
			        	lcd->char_data = TABLE[(lcd->char_pos+char_row)];
					}
					else
					{
						lcd->char_data = 0;
					}
					if(lcd->lcd_pcd_8544.show_inverse == 1)
					{
						lcd_write_data_or_cmd(lcd,1,~lcd->char_data);
					}
					else
					{
						lcd_write_data_or_cmd(lcd,1,lcd->char_data);
					}
				}
				if(lcd->lcd_pcd_8544.show_inverse == 1)
				{
					lcd_write_data_or_cmd(lcd,1,0xFF);
				}
				else
				{
					lcd_write_data_or_cmd(lcd,1,0x00);
				}


			}
			break;

		case (int)_LCD_TYPE_16x2_:
			{
				lcd_write_data_or_cmd(lcd, 1, cvar);
			}
			break;
		default:
			{
				
			}
			break;
	}

}





